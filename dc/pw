#!/usr/bin/env bash
set -euo pipefail

# COMPOSECTL PW IDENTIFIER
# COMPOSECTL_PW_ID=composectl_pw_default_v1
# This comment is used by the `dc/Makefile` install target to detect whether
# the installed `pw` script is the repository-provided default (contains
# COMPOSECTL_PW_ID) or a user-provided custom implementation. If a custom
# implementation is present in the user's install directory, the Makefile
# will avoid overwriting it.

# Simple password store backed by a single env-style file.
# Supported verbs: gen, ins, del, upd, ups, get
# Usage: pw gen <KEY>      -> generate password, store and print it
#        pw ins <KEY>      -> read password from stdin and store (fail if exists)
#        pw upd <KEY>      -> read password from stdin and update (fail if missing)
#        pw ups <KEY>      -> read password from stdin and upsert (create or update)
#        pw get <KEY>      -> print the password for KEY
#        pw del <KEY>      -> delete KEY

PW_HOME_DIR="${HOME:-$HOME}"
PW_ENV="${PW_ENV:-"prod"}"
PW_DIR="${PW_DIR:-"$PW_HOME_DIR/.local/containers"}"
PW_FILE="${PW_FILE:-"$PW_DIR/$PW_ENV.env"}"

usage() {
  echo "Usage: pw {gen|ins|upd|ups|get|del} <KEY>" >&2
  exit 2
}

if [ $# -lt 2 ]; then
  usage
fi

cmd=$1
key=$2

ensure_store() {
  if [ ! -f "$STORE_FILE" ]; then
    mkdir -p "$(dirname "$STORE_FILE")" || true
    touch "$STORE_FILE"
    chmod 600 "$STORE_FILE" || true
  fi
}

# write key=value (overwrites existing key)
write_key() {
  local k=$1
  local v=$2
  ensure_store
  # remove existing key lines
  if grep -qE "^${k}=" "$STORE_FILE" 2>/dev/null; then
    # use temporary file for atomic replace
    tmp=$(mktemp)
    grep -vE "^${k}=" "$STORE_FILE" > "$tmp" || true
    echo "${k}=${v}" >> "$tmp"
    mv "$tmp" "$STORE_FILE"
  else
    echo "${k}=${v}" >> "$STORE_FILE"
  fi
}

# remove a key
remove_key() {
  local k=$1
  if [ ! -f "$STORE_FILE" ]; then
    return 1
  fi
  if ! grep -qE "^${k}=" "$STORE_FILE" 2>/dev/null; then
    return 1
  fi
  tmp=$(mktemp)
  grep -vE "^${k}=" "$STORE_FILE" > "$tmp" || true
  mv "$tmp" "$STORE_FILE"
}

# check if key exists
key_exists() {
  if [ ! -f "$STORE_FILE" ]; then
    return 1
  fi
  if grep -qE "^${1}=" "$STORE_FILE" 2>/dev/null; then
    return 0
  fi
  return 1
}

read_stdin_no_newline() {
  # read all stdin, strip trailing newline(s)
  local val
  val=$(cat -)
  # remove trailing newlines
  val=$(printf "%s" "$val" | sed -e ':a' -e '$!{N;ba' -e '}' -e 's/\n$//' )
  printf "%s" "$val"
}

# Generate a random password consisting of URL-safe and bash-safe
# characters (default length 24). Returns the password on stdout.
generate_password() {
  # fixed default length; avoid referencing positional args to satisfy linter
  local target=24
  local allowed='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._'
  local alen=${#allowed}
  local pw=''
  while [ ${#pw} -lt "$target" ]; do
    # read 2 bytes -> number between 0 and 65535
    local num
    num=$(od -An -N2 -tu2 /dev/urandom | tr -d ' ')
    if [ -z "$num" ]; then
      continue
    fi
    local idx=$((num % alen))
    pw="${pw}${allowed:idx:1}"
  done
  printf "%s" "$pw"
}

case "$cmd" in
  gen)
    # fail if key already exists
    if key_exists "$key"; then
      echo "key already exists" >&2
      exit 1
    fi
    pw=$(generate_password)
    write_key "$key" "$pw"
    printf "%s" "$pw"
    ;;

  ins)
    # fail if key already exists
    if key_exists "$key"; then
      echo "key already exists" >&2
      exit 1
    fi
    # read password from stdin
    if [ -t 0 ]; then
      echo "pw ins requires password on stdin" >&2
      echo "Example: printf '%s' \"mypassword\" | pw ins MY_PASS" >&2
      exit 2
    fi
    val=$(read_stdin_no_newline)
    if [ -z "$val" ]; then
      echo "empty password from stdin" >&2
      exit 2
    fi
    write_key "$key" "$val"
    ;;

  upd)
    # only allow update if key exists
    if ! key_exists "$key"; then
      echo "key not found" >&2
      exit 1
    fi
    if [ -t 0 ]; then
      echo "pw upd requires password on stdin" >&2
      echo "Example: printf '%s' \"mypassword\" | pw upd MY_PASS" >&2
      exit 2
    fi
    val=$(read_stdin_no_newline)
    if [ -z "$val" ]; then
      echo "empty password from stdin" >&2
      exit 2
    fi
    write_key "$key" "$val"
    ;;

  ups)
    # upsert: read password from stdin if provided; otherwise generate one
    generate_pw=false
    if [ -t 0 ]; then
      # no stdin provided -> generate
      generate_pw=true
    else
      val=$(read_stdin_no_newline)
      if [ -z "$val" ]; then
        generate_pw=true
      fi
    fi

    if [ "$generate_pw" = true ]; then
      pw=$(generate_password)
      write_key "$key" "$pw"
      # print generated password
      printf "%s" "$pw"
    else
      # write provided password (upsert)
      write_key "$key" "$val"
    fi
    ;;

  get)
    if [ ! -f "$STORE_FILE" ]; then
      echo "key not found" >&2
      exit 1
    fi
    # print value for key
    line=$(grep -E "^${key}=" "$STORE_FILE" || true)
    if [ -z "$line" ]; then
      echo "key not found" >&2
      exit 1
    fi
    # cut only the first '=' to allow '=' in value
    value=$(printf "%s" "$line" | sed -E 's/^[^=]+=//')
    printf "%s" "$value"
    ;;

  del)
    if remove_key "$key"; then
      exit 0
    else
      echo "key not found" >&2
      exit 1
    fi
    ;;

  *)
    usage
    ;;
esac

